<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>H324MConfigInterface class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>H324MConfigInterface Class Reference</h1><code>#include &lt;<a class="el" href="tsc__h324m__config__interface_8h-source.html">tsc_h324m_config_interface.h</a>&gt;</code>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a0">SetObserver</a> (<a class="el" href="classH324MConfigObserver.html">H324MConfigObserver</a> *aObserver)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a1">SetMultiplexLevel</a> (TPVH223Level aLevel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a2">SetMaxSduSize</a> (TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a3">SetMaxSduSizeR</a> (TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a4">SetCodecPreference</a> (Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingVideo, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingVideo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a5">SetFormatSpecificInfo</a> (PVMFFormatType aMediaFormat, const uint8 *apFormatSpecificInfo, uint32 aFormatSpecificInfoLen, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a6">SetAl2SequenceNumbers</a> (int32 aSeqNumWidth, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a7">SetAl3ControlFieldOctets</a> (int32 aCfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a8">SetMaxPduSize</a> (int32 aMaxPduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a9">SetTerminalType</a> (uint8 aTerminalType, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a10">SetALConfiguration</a> (<a class="el" href="pv__2way__basic__types_8h.html#a48">TPVMediaType_t</a> aMediaType, TPVAdaptationLayer aLayer, bool aAllow, bool aUse=true, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a11">SendRme</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a12">SetMaxMuxPduSize</a> (int32 aRequestMaxMuxPduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a13">SetMaxMuxCcsrlSduSize</a> (int32 aMaxCcsrlSduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a14">FastUpdate</a> (PVMFNodeInterface &amp;aTrack, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a15">SendRtd</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a16">SetVendor</a> (uint8 cc, uint8 ext, uint32 mc, const uint8 *aProduct, uint16 aProductLen, const uint8 *aVersion, uint16 aVersionLen, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a17">SendEndSession</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a18">SetEndSessionTimeout</a> (uint32 aTimeout, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a19">SetTimerCounter</a> (TPVH324TimerCounter aTimerCounter, uint8 aSeries, uint32 aSeriesOffset, uint32 aValue, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a20">SetVideoResolutions</a> (<a class="el" href="pv__2way__basic__types_8h.html#a47">TPVDirection</a> aDirection, Oscl_Vector&lt; PVMFVideoResolutionRange, OsclMemAllocator &gt; &amp;aResolutions, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a21">SendVendorId</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a22">SendVideoTemporalSpatialTradeoffCommand</a> (TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a23">SendVideoTemporalSpatialTradeoffIndication</a> (TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a24">SendLogicalChannelActiveIndication</a> (TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a25">SendLogicalChannelInactiveIndication</a> (TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a26">SendSkewIndication</a> (TPVChannelId aLogicalChannel1, TPVChannelId aLogicalChannel2, uint16 aSkew, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a27">SetLogicalChannelBufferingMs</a> (uint32 aInBufferingMs, uint32 aOutBufferingMs, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a28">SendUserInput</a> (<a class="el" href="classCPVUserInput.html">CPVUserInput</a> *user_input, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual PVMFCommandId&nbsp;</td><td valign=bottom><a class="el" href="classH324MConfigInterface.html#a29">SetWnsrp</a> (const bool aEnableWnsrp, OsclAny *aContextData=NULL)=0</td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a14" doxytag="H324MConfigInterface::FastUpdate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::FastUpdate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTrack</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API may be called only after the media source has been successfully added to the pv2way engine. It causes the 2way engine to immediately send out a fast update frame specific to the media type identified by the aTrack parameter. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
<tr><td valign=top><em>aTrack</em>&nbsp;</td><td>
The identifier for the track </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="H324MConfigInterface::SendEndSession"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendEndSession </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OsclAny *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aContextData</em> = NULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends an end session command to the peer. Only to be used for testing purposes.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="H324MConfigInterface::SendLogicalChannelActiveIndication"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendLogicalChannelActiveIndication </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send a logicalChannelActive indication to the peer. It is an indication to the peer that the channel that was paused and for which it received logicalChannelInactive indication is now ready to send data on the channel defined by Logical channel Id     </td>
  </tr>
</table>
<a name="a25" doxytag="H324MConfigInterface::SendLogicalChannelInactiveIndication"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendLogicalChannelInactiveIndication </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send a logicalChannelInactive indication to the peer. It is an indication to the peer that the channel has been paused the channel and will not send any data on the channel defined by Logical channel Id     </td>
  </tr>
</table>
<a name="a11" doxytag="H324MConfigInterface::SendRme"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendRme </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OsclAny *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aContextData</em> = NULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify whether Request Multiplex Entry is sent to the remote terminal after TCS<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aSendRme</em>&nbsp;</td><td>
If true, RME is sent to the peer after TCS </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="H324MConfigInterface::SendRtd"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendRtd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OsclAny *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aContextData</em> = NULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a Round Trip Determination message to the peer and indicates the round trip delay to the caller on completion of the command. The round trip delay is stored in 4 bytes in the local buffer of the completion event in network byte order.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="H324MConfigInterface::SendSkewIndication"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendSkewIndication </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSkew</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send a SkewIndication to the peer. Skew is measured in milliseconds, and indicates the maximum number of milliseconds that the data on logicalChannel2 is delayed from the data on logicalChannel1 as delivered to the network transport.     </td>
  </tr>
</table>
<a name="a28" doxytag="H324MConfigInterface::SendUserInput"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendUserInput </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classCPVUserInput.html">CPVUserInput</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>user_input</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Causes the pv2way to send the specified user input to the remote terminal using control channel. The user input can be either DTMF ot Alphanumeric <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>user_input</em>&nbsp;</td><td>
A pointer to either <a class="el" href="classCPVUserInputDtmf.html">CPVUserInputDtmf</a> or <a class="el" href="classCPVUserInputAlphanumeric.html">CPVUserInputAlphanumeric</a> </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="H324MConfigInterface::SendVendorId"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendVendorId </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OsclAny *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aContextData</em> = NULL          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send the vendor id info to the peer. Note: Calling this API during call-setup negotiations can affect the time for call-setup adversely.     </td>
  </tr>
</table>
<a name="a22" doxytag="H324MConfigInterface::SendVideoTemporalSpatialTradeoffCommand"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendVideoTemporalSpatialTradeoffCommand </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTradeoff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send a videoTemporalSpatialTradeOff command to the peer. It is a request to the remote encoder to adjust its encoding in accordance with the tradeoff value. A value of 0 indicates a high spatial resolution and a value of 31 indicates a high frame rate. The values from 0 to 31 indicate monotonically a higher frame rate. Actual values do not correspond to precise values of spatial resolution or frame rate.     </td>
  </tr>
</table>
<a name="a23" doxytag="H324MConfigInterface::SendVideoTemporalSpatialTradeoffIndication"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SendVideoTemporalSpatialTradeoffIndication </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVChannelId&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTradeoff</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to send a videoTemporalSpatialTradeOff command to the peer. It is an indication to the remote decoder that the local encoder has adjusted its encoding parameters according to the tradeoff value. A value of 0 indicates a high spatial resolution and a value of 31 indicates a high frame rate. The values from 0 to 31 indicate monotonically a higher frame rate. Actual values do not correspond to precise values of spatial resolution or frame rate.     </td>
  </tr>
</table>
<a name="a6" doxytag="H324MConfigInterface::SetAl2SequenceNumbers"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetAl2SequenceNumbers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSeqNumWidth</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the sequence number field for AL2<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aSeqNumWidth</em>&nbsp;</td><td>
The number of octets to use for AL2 sequence numbers. Allowed values are 0, 1.</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="H324MConfigInterface::SetAl3ControlFieldOctets"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetAl3ControlFieldOctets </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aCfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the control field octets field for AL3<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aCfo</em>&nbsp;</td><td>
The number of octets to use for AL3 CFO. Allowed values are 0, 1, 2.</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="H324MConfigInterface::SetALConfiguration"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetALConfiguration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="pv__2way__basic__types_8h.html#a48">TPVMediaType_t</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMediaType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>TPVAdaptationLayer&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAllow</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aUse</em> = true, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the allowable adaptation layers for audio and video. By default AL2 is allowed for audio and AL2, AL3 are allowed for video<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aMediaType</em>&nbsp;</td><td>
The media type, i.e audio, video, data </td></tr>
<tr><td valign=top><em>aLayer</em>&nbsp;</td><td>
The adaptation layer </td></tr>
<tr><td valign=top><em>aAllow</em>&nbsp;</td><td>
Is this adaptation layer allowed for this media type ? </td></tr>
<tr><td valign=top><em>aUse</em>&nbsp;</td><td>
Is this adaptation layer used for video media type ? </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="H324MConfigInterface::SetCodecPreference"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetCodecPreference </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aIncomingAudio</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aIncomingVideo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aOutGoingAudio</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aOutGoingVideo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the preference order for supported media codecs. If input vector has elements, then only these elements are used in terminal capabilities exchange.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aIncomingAudio</em>&nbsp;</td><td>
The incoming audio decoder preference order </td></tr>
<tr><td valign=top><em>aIncomingVideo</em>&nbsp;</td><td>
The incoming video decoder preference order </td></tr>
<tr><td valign=top><em>aOutgoingAudio</em>&nbsp;</td><td>
The outgoing audio encoder preference order </td></tr>
<tr><td valign=top><em>aOutgoingVideo</em>&nbsp;</td><td>
The outgoing video decoder preference order </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="H324MConfigInterface::SetEndSessionTimeout"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetEndSessionTimeout </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeout</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the disconnect timeout interval.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aTimeout</em>&nbsp;</td><td>
The timeout value in seconds </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="H324MConfigInterface::SetFormatSpecificInfo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetFormatSpecificInfo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PVMFFormatType&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMediaFormat</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>apFormatSpecificInfo</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aFormatSpecificInfoLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the format specific info for supported media encoders.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aMediaFormat</em>&nbsp;</td><td>
The outgoing media format </td></tr>
<tr><td valign=top><em>apFormatSpecificInfo</em>&nbsp;</td><td>
The format specific info </td></tr>
<tr><td valign=top><em>aFormatSpecificInfoLen</em>&nbsp;</td><td>
The length of the format specific info in bytes </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="H324MConfigInterface::SetLogicalChannelBufferingMs"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetLogicalChannelBufferingMs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aInBufferingMs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aOutBufferingMs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to configure the logical channel buffer sizes for incoming and outgoing logical channels. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aDirection</em>&nbsp;</td><td>
The direction (Rx or Tx). </td></tr>
<tr><td valign=top><em>aBufferingMs</em>&nbsp;</td><td>
The amount of buffering in milliseconds. </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="H324MConfigInterface::SetMaxMuxCcsrlSduSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMaxMuxCcsrlSduSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMaxCcsrlSduSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API sets the max ccsrl sdu size<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aMaxCcsrlSduSize</em>&nbsp;</td><td>
The max ccsrl sdu size </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="H324MConfigInterface::SetMaxMuxPduSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMaxMuxPduSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aRequestMaxMuxPduSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API causes a maxMuxPduSize request to be sent to the remote terminal if set to a valid value (64 - 255). This is done after TCS if the remote terminal supports the maxMuxPduCapability<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aRequestMaxMuxPduSize</em>&nbsp;</td><td>
The max mux pdu size </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="H324MConfigInterface::SetMaxPduSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMaxPduSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMaxPduSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to limit the size of the outgoing h223 pdus<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aMaxPduSize</em>&nbsp;</td><td>
The max pdu size</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="H324MConfigInterface::SetMaxSduSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMaxSduSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVAdaptationLayer&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify maximum outgoing sdu sizes for each adaptation layer<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLayer</em>&nbsp;</td><td>
The h223 adaptation layer type </td></tr>
<tr><td valign=top><em>aSize</em>&nbsp;</td><td>
The sdu size</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="H324MConfigInterface::SetMaxSduSizeR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMaxSduSizeR </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVAdaptationLayer&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify maximum incoming sdu sizes for each adaptation layer. This is indicated to the peer via the TCS<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLayer</em>&nbsp;</td><td>
The h223 adaptation layer type </td></tr>
<tr><td valign=top><em>aSize</em>&nbsp;</td><td>
The sdu size</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="H324MConfigInterface::SetMultiplexLevel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetMultiplexLevel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVH223Level&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLevel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the starting H223 multiplex level<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLevel</em>&nbsp;</td><td>
The starting H223 multiplex level. Note that the final level that is neotiated will depend on the starting level of the peer</td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a0" doxytag="H324MConfigInterface::SetObserver"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void H324MConfigInterface::SetObserver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classH324MConfigObserver.html">H324MConfigObserver</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aObserver</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify separate observers for the 324m interface. Otherwise, the default observers will be used<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aObserver</em>&nbsp;</td><td>
the observer for command status and for unsolicited informational events </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="H324MConfigInterface::SetTerminalType"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetTerminalType </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTerminalType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the terminal type that is advertized to the peer. This can be used to force the local terminal to be master/slave when communicating with a peer 324m terminal for testing purposes.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aTerminalType</em>&nbsp;</td><td>
The terminal type </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="H324MConfigInterface::SetTimerCounter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetTimerCounter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TPVH324TimerCounter&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimerCounter</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSeries</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSeriesOffset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aValue</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets an H.324 timer/counter value. This should be called before ConnectL is invoked. The supported timers are: T106 Master Slave Determination (in units of 1s) T101 Capability Exchange (in units of 1s) T103 Uni-directional and Bi-directional Logical Channel Signalling (in units of 1s) T108 Close Logical Channel (in units of 1s) T104 H.223 Multiplex Table (in units of 1s) T109 Mode Request (in units of 1s) T105 Round Trip Delay (in units of 1s) T107 Request Multiplex Entry (in units of 100ms) T401 SRP retransmission (in units of 100ms) The supported counters are: N100 H245 (TCS, MSD) N401 SRP retransmission <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aTimerCounter</em>&nbsp;</td><td>
Identifies whether a timer or counter is being set. </td></tr>
<tr><td valign=top><em>aSeries</em>&nbsp;</td><td>
Identifies the H.324 timer/counter series. </td></tr>
<tr><td valign=top><em>aSeriesOffset</em>&nbsp;</td><td>
Specifies the offset within a particular series. E.g. aTimerCounter=EH324Timer, aSeries=1, aSeriesOffset=1 indicates T101. aTimerCounter=EH324Timer, aSeries=4, aSeriesOffset=1 indicates T401. aTimerCounter=EH324Counter, aSeries=4, aSeriesOffset=1 indicates T401. </td></tr>
<tr><td valign=top><em>aValue</em>&nbsp;</td><td>
The new value for the H.324 timer/counter </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="H324MConfigInterface::SetVendor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetVendor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ext</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aProduct</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aProductLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aVersion</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aVersionLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the vendor identification data. This does not cause the stack to issue a vendor identifiation request. Set to NULL to disable sending vendor id. If set to a valid parameter before Connect, it will cause the stack to automatically send it along with the TCS message. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>cc</em>&nbsp;</td><td>
T35 Country code </td></tr>
<tr><td valign=top><em>ext</em>&nbsp;</td><td>
T35 Extension </td></tr>
<tr><td valign=top><em>mc</em>&nbsp;</td><td>
T35 Manufacturer code </td></tr>
<tr><td valign=top><em>aProduct</em>&nbsp;</td><td>
Product number </td></tr>
<tr><td valign=top><em>aVersion</em>&nbsp;</td><td>
Version number </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="H324MConfigInterface::SetVideoResolutions"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetVideoResolutions </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="pv__2way__basic__types_8h.html#a47">TPVDirection</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aDirection</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Oscl_Vector&lt; PVMFVideoResolutionRange, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aResolutions</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows the user to specify the supported resolutions for video for transmit and receive.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aDirection</em>&nbsp;</td><td>
The direction (Tx/Rx) for which the capability is specified. </td></tr>
<tr><td valign=top><em>aResolutions</em>&nbsp;</td><td>
An array of resolutions. </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a29" doxytag="H324MConfigInterface::SetWnsrp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual PVMFCommandId H324MConfigInterface::SetWnsrp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aEnableWnsrp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OsclAny *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContextData</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Causes the pv2way to send the specified user input to the remote terminal using control channel. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aEnableWnsrp</em>&nbsp;</td><td>
Boolean whether to enable Wnsrp or not </td></tr>
<tr><td valign=top><em>aContextData</em>&nbsp;</td><td>
Optional opaque data that will be passed back to the user with the command response</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
A unique command id for asynchronous completion </dl>    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tsc__h324m__config__interface_8h-source.html">tsc_h324m_config_interface.h</a></ul>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>PV2Way Engine</small>
<address style="align: left;"><small>Posting Version: CORE_8.509.1.3 </small>
</small></address>
</body>
</html>
